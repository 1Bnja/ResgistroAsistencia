"""
API de Reconocimiento Facial - Sistema de Asistencia
Servicio Flask que procesa imÃ¡genes, reconoce rostros y se comunica con el backend
"""

import os
import pickle
import base64
import cv2
import numpy as np
import face_recognition
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS

# ==========================================
# CONFIGURACIÃ“N
# ==========================================

app = Flask(__name__)
CORS(app)

# URLs de servicios
BACKEND_URL = os.environ.get('BACKEND_URL', 'http://api-backend:3000/api')

# Archivo para almacenar encodings
DATOS_ROSTROS = "rostros_conocidos.dat"

# Cargar rostros conocidos al iniciar
nombres_conocidos = []
encodings_conocidos = []

print("ðŸ”„ Cargando rostros conocidos...")
try:
    with open(DATOS_ROSTROS, "rb") as f:
        datos_guardados = pickle.load(f)
        nombres_conocidos = datos_guardados['nombres']
        encodings_conocidos = datos_guardados['encodings']
    print(f"âœ… Se cargaron {len(nombres_conocidos)} rostros conocidos.")
except (FileNotFoundError, EOFError):
    print("âš ï¸ No se encontrÃ³ archivo de datos. Empezando desde cero.")


# ==========================================
# FUNCIONES AUXILIARES
# ==========================================

def guardar_rostros():
    """Guarda la lista de nombres y encodings en un archivo."""
    if not nombres_conocidos:
        print("âš ï¸ No hay datos que guardar.")
        return
    
    print(f"ðŸ’¾ Guardando {len(nombres_conocidos)} rostros...")
    try:
        with open(DATOS_ROSTROS, "wb") as f:
            pickle.dump({
                'nombres': nombres_conocidos,
                'encodings': encodings_conocidos
            }, f)
        print("âœ… Datos guardados exitosamente!")
    except Exception as e:
        print(f"âŒ Error al guardar los datos: {e}")



def obtener_usuarios_backend():
    """Obtiene la lista de usuarios activos desde el backend."""
    try:
        response = requests.get(
            f"{BACKEND_URL}/usuarios",
            params={"activo": "true"},
            timeout=5
        )
        if response.status_code == 200:
            data = response.json()
            return data.get('data', [])
        else:
            print(f"âš ï¸ Error al obtener usuarios: {response.status_code}")
            return []
    except Exception as e:
        print(f"âŒ Error conectando con backend: {e}")
        return []


def sincronizar_encodings():
    """
    Sincroniza los encodings locales con los usuarios del backend.
    Obtiene usuarios que tienen encodingFacial y los carga en memoria.
    """
    global nombres_conocidos, encodings_conocidos
    
    print("ðŸ”„ Sincronizando encodings con backend...")
    usuarios = obtener_usuarios_backend()
    
    nombres_nuevos = []
    encodings_nuevos = []
    
    for usuario in usuarios:
        if usuario.get('encodingFacial'):
            try:
                # Decodificar encoding desde string (base64 o pickle)
                encoding_str = usuario['encodingFacial']
                encoding_bytes = base64.b64decode(encoding_str)
                encoding = pickle.loads(encoding_bytes)
                
                # Usar el ID del usuario como identificador Ãºnico
                usuario_id = str(usuario['_id'])
                nombres_nuevos.append(usuario_id)
                encodings_nuevos.append(encoding)
            except Exception as e:
                print(f"âš ï¸ Error procesando encoding de {usuario.get('nombre')}: {e}")
    
    nombres_conocidos = nombres_nuevos
    encodings_conocidos = encodings_nuevos
    
    # Guardar en archivo local
    guardar_rostros()
    print(f"âœ… Sincronizados {len(nombres_conocidos)} encodings")


def registrar_marcaje_backend(usuario_id, confianza, tipo='entrada'):
    """Registra un marcaje en el backend."""
    try:
        response = requests.post(
            f"{BACKEND_URL}/marcajes/reconocimiento",
            json={
                "usuarioId": usuario_id,
                "confianza": float(confianza),
                "tipo": tipo
            },
            timeout=10
        )
        
        if response.status_code in [200, 201]:
            return response.json()
        else:
            print(f"âš ï¸ Error al registrar marcaje: {response.status_code}")
            return {"success": False, "message": "Error en backend"}
    except Exception as e:
        print(f"âŒ Error registrando marcaje: {e}")
        return {"success": False, "message": str(e)}


def imagen_base64_a_array(imagen_base64):
    """Convierte una imagen base64 a array numpy para OpenCV."""
    try:
        # Eliminar prefijo data:image si existe
        if ',' in imagen_base64:
            imagen_base64 = imagen_base64.split(',')[1]
        
        # Decodificar base64
        img_bytes = base64.b64decode(imagen_base64)
        img_array = np.frombuffer(img_bytes, dtype=np.uint8)
        
        # Decodificar imagen
        frame = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
        
        if frame is None:
            raise ValueError("No se pudo decodificar la imagen")
        
        return frame
    except Exception as e:
        raise ValueError(f"Error decodificando imagen: {e}")


def procesar_frame_reconocimiento(frame):
    """
    Procesa un frame y reconoce rostros.
    Retorna lista de rostros detectados con sus datos.
    """
    # Redimensionar para acelerar procesamiento
    rgb_small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)
    rgb_small_frame = cv2.cvtColor(rgb_small_frame, cv2.COLOR_BGR2RGB)
    
    # Detectar rostros
    face_locations = face_recognition.face_locations(rgb_small_frame, model="cnn")
    face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)
    
    rostros_detectados = []
    
    for i, face_encoding in enumerate(face_encodings):
        # Coordenadas del rostro (escaladas de vuelta)
        top, right, bottom, left = face_locations[i]
        top *= 4
        right *= 4
        bottom *= 4
        left *= 4
        
        # Intentar reconocer
        usuario_id = None
        confianza = 0.0
        nombre = "Desconocido"
        
        if len(encodings_conocidos) > 0:
            # Comparar con rostros conocidos
            distancias = face_recognition.face_distance(encodings_conocidos, face_encoding)
            mejor_indice = np.argmin(distancias)
            mejor_distancia = distancias[mejor_indice]
            
            # Umbral de confianza (0.6 = estricto, 0.7 = moderado)
            if mejor_distancia < 0.6:
                usuario_id = nombres_conocidos[mejor_indice]
                confianza = 1.0 - mejor_distancia
                nombre = f"Usuario {usuario_id[:8]}"  # Mostrar primeros 8 chars del ID
        
        rostros_detectados.append({
            'usuario_id': usuario_id,
            'nombre': nombre,
            'confianza': round(confianza, 3),
            'reconocido': usuario_id is not None,
            'bbox': {
                'left': int(left),
                'top': int(top),
                'width': int(right - left),
                'height': int(bottom - top)
            }
        })
    
    return rostros_detectados


# ==========================================
# RUTAS DE LA API
# ==========================================

@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint."""
    return jsonify({
        'status': 'ok',
        'service': 'api-ia-reconocimiento',
        'rostros_cargados': len(nombres_conocidos)
    }), 200


@app.route('/recognize', methods=['POST'])
def recognize():
    """
    Procesa una imagen y reconoce rostros.
    
    Body (JSON):
    {
        "image": "data:image/jpeg;base64,..." o base64 directo
    }
    
    Respuesta:
    {
        "success": true,
        "rostros": [
            {
                "usuario_id": "507f1f77bcf86cd799439011",
                "nombre": "Usuario 507f1f77",
                "confianza": 0.952,
                "reconocido": true,
                "bbox": { "left": 100, "top": 50, "width": 200, "height": 250 }
            }
        ]
    }
    """
    try:
        data = request.get_json()
        
        if not data or 'image' not in data:
            return jsonify({
                'success': False,
                'message': 'No se proporcionÃ³ imagen'
            }), 400
        
        # Convertir imagen base64 a array
        frame = imagen_base64_a_array(data['image'])
        
        # Procesar reconocimiento
        rostros = procesar_frame_reconocimiento(frame)
        
        return jsonify({
            'success': True,
            'rostros': rostros,
            'total_detectados': len(rostros)
        }), 200
        
    except ValueError as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 400
    except Exception as e:
        print(f"âŒ Error en /recognize: {e}")
        return jsonify({
            'success': False,
            'message': 'Error procesando imagen'
        }), 500


# --- 6. Iniciar el Servidor ---

if __name__ == '__main__':
    print("Iniciando servidor Flask en http://0.0.0.0:5000")
    # threaded=True permite que el servidor maneje mÃºltiples peticiones (el stream y el guardado) a la vez
    # host='0.0.0.0' es crucial para que sea accesible desde fuera del contenedor Docker
    app.run(host='0.0.0.0', port=5000, threaded=True)